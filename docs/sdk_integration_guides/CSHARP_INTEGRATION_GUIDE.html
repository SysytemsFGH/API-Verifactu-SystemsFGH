<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Guía de Integración VeriFactu para C# (.NET 8.0)</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f9f9f9;
        }

        h1 {
            color: #2c3e50;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
        }

        h2 {
            color: #2980b9;
            margin-top: 30px;
            border-bottom: 1px solid #ddd;
            padding-bottom: 5px;
        }

        h3 {
            color: #16a085;
            margin-top: 25px;
        }

        p {
            margin-bottom: 15px;
        }

        ul,
        ol {
            margin-bottom: 15px;
            padding-left: 20px;
        }

        li {
            margin-bottom: 5px;
        }

        code {
            font-family: Consolas, "Courier New", monospace;
            background-color: #f4f4f4;
            padding: 2px 5px;
            border-radius: 3px;
            color: #c7254e;
        }

        pre {
            background-color: #2c3e50;
            color: #ecf0f1;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            font-family: Consolas, "Courier New", monospace;
        }

        pre code {
            background-color: transparent;
            color: inherit;
            padding: 0;
        }

        blockquote {
            border-left: 4px solid #3498db;
            margin: 0;
            padding: 10px 20px;
            background-color: #eef9fd;
            color: #555;
        }

        .note {
            background-color: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 10px 20px;
            margin-bottom: 15px;
        }

        hr {
            border: 0;
            height: 1px;
            background: #ddd;
            margin: 40px 0;
        }
    </style>
</head>

<body>

    <h1>Guía de Integración VeriFactu para C# (.NET 8 / Core)</h1>

    <blockquote>
        <strong>Resumen</strong>: Esta guía documenta la integración técnica del adaptador "Micro Server" en
        entornos .NET modernos. Permite delegar la complejidad criptográfica y de comunicación con la AEAT a un
        backend intermedio, diseñado para cumplir con la normativa VeriFactu de forma robusta y sencilla.
    </blockquote>

    <hr>

    <h2>1. Arquitectura del Motor (Engine C#)</h2>

    <p>La integración se basa en el uso estándar de <code>HttpClient</code> y <code>System.Text.Json</code>. No requiere
        librerías de terceros (NuGet) más allá de las incluidas en el SDK de .NET.</p>

    <h3>Componentes Principales</h3>
    <p>La clase <code>VFEngine.cs</code> encapsula toda la comunicación:</p>

    <ol>
        <li>
            <strong><code>VFEngine</code> (Cliente API)</strong>
            <ul>
                <li><strong>Transporte</strong>: Usa <code>HttpClient</code> con soporte para inyección de dependencias
                    (DI) o instanciación directa.</li>
                <li><strong>Seguridad</strong>: Maneja headers de autenticación (Bearer Token) y permite (opcionalmente)
                    ignorar errores SSL para entornos de desarrollo local.</li>
                <li><strong>JSON</strong>: Utiliza <code>System.Text.Json.Nodes.JsonNode</code> para manipular payloads
                    dinámicos fácilmente.</li>
            </ul>
        </li>
    </ol>

    <p><strong>Orquestación</strong>: Maneja la <strong>Máquina de Estados</strong> implícita de la normativa:</p>
    <ol>
        <li><strong>INGESTA</strong>: Envío del JSON al Backend.</li>
        <li><strong>POLLING</strong>: Consulta de la cola de "Pendientes" (facturas ya procesadas por el
            worker y enviadas a la AEAT) esperando la confirmación (ACK).</li>
        <li><strong>ACK</strong>: Confirmación de recepción (borrado de la cola) tras guardar Huella y
            QR.</li>
    </ol>

    <hr>

    <h2>2. Configuración del JSON (Altas, Subsanaciones y Anulaciones)</h2>

    <p>No encontrará en esta guía una documentación exhaustiva sobre cómo construir el JSON campo a campo.
        <strong>¡No es necesario!</strong>
    </p>

    <p>El <strong>Panel de Administración Web</strong> del Micro Server (sección <strong>Envíos</strong>) incluye
        una herramienta de <strong>Generación de Payloads</strong> interactiva diseñada específicamente para
        desarrolladores.</p>

    <div class="note">
        <strong>Nota sobre <code>metadata</code></strong>: El esquema JSON exige un bloque <code>metadata</code> en
        la raíz. Aunque actualmente su contenido es ignorado, <strong>debe estar presente</strong> para pasar la
        validación del esquema.
    </div>

    <hr>

    <h2>3. Flujo de Trabajo Típico: "Alta de Factura"</h2>

    <p>El Backend actúa como un <strong>buffer inteligente</strong>. Su aplicación C# no habla con la AEAT
        directamente; habla con este Micro Server.</p>

    <h3>Paso 1: Ingesta (`/v1/ingesta`)</h3>
    <p>Su aplicación genera el objeto JSON con los datos de la factura y lo envía.</p>

    <ul>
        <li><strong>Respuesta Inmediata</strong>: El Backend valida y guarda. Retorna <code>200 OK</code>.</li>
        <li><strong>Estado</strong>: La factura <strong>AÚN NO</strong> ha ido a la AEAT. Un "Worker" en
            segundo plano la tomará, firmará, encadenará y enviará.</li>
    </ul>

    <pre><code>public async Task&lt;JsonNode?&gt; IngestaJsonAsync(JsonNode json)
{
    var content = new StringContent(json.ToString(), Encoding.UTF8, "application/json");
    var response = await _client.PostAsync("/v1/ingesta", content);
    
    if (response.IsSuccessStatusCode)
    {
        var result = await response.Content.ReadAsStringAsync();
        return JsonNode.Parse(result);
    }
    // Handle error...
    return null;
}</code></pre>

    <h3>Paso 2: Espera Activa / Polling (`/verifactu/pendientes`)</h3>
    <p>El sistema debe preguntar periódicamente al endpoint de pendientes.</p>

    <ul>
        <li>El Backend devuelve las facturas que la AEAT ya ha contestado.</li>
        <li>Incluye la <strong>Huella</strong>, el <strong>CSV</strong> y la <strong>UrlQR</strong>.</li>
    </ul>

    <pre><code>public async Task&lt;JsonNode?&gt; GetPendientesAsync(string nifEmisor, int limit = 50)
{
    var response = await _client.GetAsync($"/verifactu/pendientes?nif_emisor={nifEmisor}&n_ultimos={limit}");
    // ... parse response
}</code></pre>

    <h3>Paso 3: Confirmación (`/verifactu/ack`)</h3>
    <p>Una vez recuperados los datos finales (QR y Huella):</p>
    <ol>
        <li>Guárdelos en su base de datos local asociados a la factura.</li>
        <li>Envíe un <strong>ACK</strong> al Backend indicando el <code>indice_log</code>.</li>
        <li>El Backend marca esa operación como "Entregada" y la saca de la cola.</li>
    </ol>

    <pre><code>public async Task&lt;JsonNode?&gt; AckIndiceAsync(string nifEmisor, int indiceLog)
{
    var payload = new { nif_emisor = nifEmisor, indice_log = indiceLog };
    var content = new StringContent(JsonSerializer.Serialize(payload), Encoding.UTF8, "application/json");
    var response = await _client.PostAsync("/verifactu/ack", content);
    // ...
}</code></pre>

    <hr>

    <h2>4. Configuración (`Config.json`)</h2>

    <p>La demo utiliza un archivo JSON simple para la configuración:</p>

    <pre><code>{
  "api": {
    "base_url": "http://localhost:8000",
    "timeout_sec": 60,
    "token": "",
    "ssl_verify": false
  },
  "demo": {
    "nif_emisor": "B12345678"
  }
}</code></pre>

    <hr>

    <h2>5. Visualización de QR en C#</h2>

    <p>El backend devuelve la URL pública del QR (<code>url_qr_verifactu</code>) y opcionalmente el contenido en Base64
        (<code>qr_verifactu</code>).</p>

    <h3>WinForms / WPF</h3>
    <p>Si usa el Base64, puede cargarlo directamente en memoria sin descargar nada:</p>

    <pre><code>// Ejemplo Helper para convertir Base64 a Image (System.Drawing)
public Image Base64ToImage(string base64String)
{
    byte[] imageBytes = Convert.FromBase64String(base64String);
    using (var ms = new MemoryStream(imageBytes, 0, imageBytes.Length))
    {
        return Image.FromStream(ms, true);
    }
}</code></pre>

    <h3>ASP.NET Core / Blazor</h3>
    <p>Muestre la URL directamente en una etiqueta <code>&lt;img&gt;</code> o enlace.</p>

    <hr>

    <h2>6. Solución de Problemas (Troubleshooting)</h2>

    <h3>Excepción SSL (The underlying connection was closed)</h3>
    <ul>
        <li><strong>Causa</strong>: Certificado auto-firmado en entorno local.</li>
        <li><strong>Solución</strong>: Use un <code>HttpClientHandler</code> con
            <code>ServerCertificateCustomValidationCallback</code> devolviendo <code>true</code> (solo desarrollo).</li>
    </ul>

    <h3>Timeout en "Pendientes"</h3>
    <ul>
        <li><strong>Causa</strong>: La AEAT tarda en responder.</li>
        <li><strong>Solución</strong>: El sistema es asíncrono. Siga consultando <code>GetPendientesAsync</code> más
            tarde.</li>
    </ul>

    <hr>

    <h2>7. Ejemplo de Integración: Ciclo Completo (Task)</h2>

    <pre><code>public async Task CicloCompleto(string nif, string serie, string num)
{
    // 1. Ingesta
    var resIngesta = await _engine.IngestaJsonAsync(miFacturaJson);
    if (resIngesta["ok"].GetValue&lt;bool&gt;()) 
    {
        Console.WriteLine("Enviado. Esperando...");
    }

    // 2. Polling
    JsonNode? statusState = null;
    for (int i=0; i&lt;10; i++)
    {
        await Task.Delay(1000);
        // CheckStatusAsync consulta /v1/check_status
        statusState = await _engine.CheckStatusAsync(nif, serie, num);
        
        if (statusState?["status"]?.ToString() != "pending") 
            break;
    }

    if (statusState == null) throw new Exception("Timeout");

    // 3. ACK
    if (statusState["status"]?.ToString() == "OK")
    {
        int id = statusState["indice_log"]?.GetValue&lt;int&gt;() ?? 0;
        if (id > 0)
        {
            await _engine.AckIndiceAsync(nif, id);
            Console.WriteLine("Confirmado correctamente.");
        }
    }
}</code></pre>

    <hr>

    <h2>8. Casos de Uso Avanzados</h2>

    <h3>8.1. Ingesta Asíncrona (Solo Envío)</h3>
    <p>Para aplicaciones de consola o servicios Windows que procesan facturas en masa.</p>

    <pre><code>// Enviar y olvidar
var res = await _engine.IngestaJsonAsync(factura);
if (res["ok"].GetValue&lt;bool&gt;())
{
    Logger.Info($"Factura {serie}-{num} encolada. Tracking: {res["tracking"]}");
}</code></pre>

    <h3>8.2. Servicio de Sincronización (Worker Service)</h3>
    <p>Un `BackgroundService` en .NET que corre continuamente.</p>

    <pre><code>protected override async Task ExecuteAsync(CancellationToken stoppingToken)
{
    while (!stoppingToken.IsCancellationRequested)
    {
        var pendientes = await _engine.GetPendientesAsync("B12345678");
        // Iterar, guardar y ACK...
        
        await Task.Delay(60000, stoppingToken); // Esperar 1 min
    }
}</code></pre>

</body>

</html>